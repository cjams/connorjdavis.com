"""
FastAPI Blog Backend
Generated by WordPress Migration Tool
Enhanced with MDX support
"""

from fastapi import FastAPI, HTTPException
from fastapi.staticfiles import StaticFiles
from fastapi.middleware.cors import CORSMiddleware
from pathlib import Path
import json
import frontmatter
from typing import List, Optional, Dict, Any
from app.mdx_processor import MDXProcessor

app = FastAPI(title="Blog API", version="2.0.0")

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000", "http://localhost:3001", "http://localhost:5173"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Mount static files
app.mount("/static", StaticFiles(directory="static"), name="static")

# Initialize MDX processor
content_dir = Path("content")
mdx_processor = MDXProcessor(content_dir)

# Load content index
def load_content_index():
    index_file = Path("content/index.json")
    if index_file.exists():
        with open(index_file, 'r', encoding='utf-8') as f:
            return json.load(f)
    return {"posts": [], "pages": [], "categories": [], "tags": []}

def load_post_content(filename: str, content_type: str = "posts"):
    """Load the full content of a post or page"""
    content_dir_path = Path(f"content/{content_type}")
    file_path = content_dir_path / filename
    
    if not file_path.exists():
        return None
    
    # Check if it's an MDX file
    if file_path.suffix == '.mdx':
        return mdx_processor.load_mdx_file(file_path)
    
    # Fallback to regular markdown
    with open(file_path, 'r', encoding='utf-8') as f:
        post_obj = frontmatter.load(f)
    
    return {
        'metadata': post_obj.metadata,
        'content': post_obj.content,
        'components': [],
        'toc': '',
        'raw_content': post_obj.content
    }

@app.get("/")
async def root():
    return {"message": "Blog API is running"}

@app.get("/posts")
async def get_posts(page: Optional[int] = 1, per_page: Optional[int] = 10, limit: Optional[int] = None, category: Optional[str] = None, tag: Optional[str] = None):
    """Get all posts with optional filtering and pagination"""
    index = load_content_index()
    posts = index['posts']
    
    # Filter by category
    if category:
        posts = [p for p in posts if category in p.get('categories', [])]
    
    # Filter by tag
    if tag:
        posts = [p for p in posts if tag in p.get('tags', [])]
    
    # Calculate total before pagination
    total = len(posts)
    
    # Handle legacy limit parameter (for backwards compatibility)
    if limit:
        posts = posts[:limit]
        return posts
    
    # Calculate pagination
    total_pages = (total + per_page - 1) // per_page  # Ceiling division
    start_idx = (page - 1) * per_page
    end_idx = start_idx + per_page
    
    # Apply pagination
    paginated_posts = posts[start_idx:end_idx]
    
    return {
        "posts": paginated_posts,
        "total": total,
        "page": page,
        "per_page": per_page,
        "total_pages": total_pages
    }

@app.get("/posts/{slug}")
async def get_post(slug: str):
    """Get a specific post by slug"""
    index = load_content_index()
    
    # Find post in index
    post_meta = None
    for post in index['posts']:
        if post.get('slug') == slug:
            post_meta = post
            break
    
    if not post_meta:
        raise HTTPException(status_code=404, detail="Post not found")
    
    # Load full content
    post_content = load_post_content(post_meta['filename'])
    if not post_content:
        raise HTTPException(status_code=404, detail="Post content not found")
    
    return {
        **post_meta,
        'content': post_content['content'],
        'components': post_content.get('components', []),
        'toc': post_content.get('toc', ''),
        'full_metadata': post_content['metadata']
    }

@app.get("/pages/{slug}")
async def get_page(slug: str):
    """Get a specific page by slug"""
    index = load_content_index()
    
    # Find page in index
    page_meta = None
    for page in index['pages']:
        if page.get('slug') == slug:
            page_meta = page
            break
    
    if not page_meta:
        raise HTTPException(status_code=404, detail="Page not found")
    
    # Load full content
    page_content = load_post_content(page_meta['filename'], 'pages')
    if not page_content:
        raise HTTPException(status_code=404, detail="Page content not found")
    
    return {
        **page_meta,
        'content': page_content['content'],
        'full_metadata': page_content['metadata']
    }

@app.get("/categories")
async def get_categories():
    """Get all categories"""
    index = load_content_index()
    return index['categories']

@app.get("/tags")
async def get_tags():
    """Get all tags"""
    index = load_content_index()
    return index['tags']

@app.get("/stats")
async def get_stats():
    """Get blog statistics"""
    index = load_content_index()
    return {
        'total_posts': len(index['posts']),
        'total_pages': len(index['pages']),
        'total_categories': len(index['categories']),
        'total_tags': len(index['tags']),
        'last_updated': index.get('generated_at')
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000, reload=True)
